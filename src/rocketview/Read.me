time	GPSTime	TimeObserver.java
----	-------	-----------------
expects 6 bytes
    0 year 1 month 2 day
    3 hour 4 minute 5 second
display: rocket time: 20yy/mm/dd hh:mm:ss

gps position	GPSLatLon	GPSPositionObserver.java
------------	---------	------------------------
interprets 8 bytes of can as 2 4-byte integers

foreach value:
    radians = |value| / 100,000,000
    displayed = toDegrees(radians)

positive = N or E
negative = S or W

display: xx.xxxx N | S xx.xxx E | W

gps status	GPSID	GPSObserver.java
----------	-----	----------------
expects 3 bytes
if byte1=0 and byte2=0
    locked
else
    not locked
display: byte0 sats byte1<binary> byte2<binary>

gps height	GPSHeight	GPSHeightObserver.java
----------	---------	----------------------
expects one 4-byte integer interpreted as
display = value / 100 meters

display: GPS height: xxxm

barometric altitude	PressValue	PressureHeightObserver.java
-------------------	----------	---------------------------
Updates the barometric altitude box with altitude

expects one 4-byte integer interpreted as
display = 44331.514 - Math.pow(18411.8956 * value, 0.1902632)

display: pressure: xxxxxxx  height xxxxxxxm

		IMUGyro
6 stripcharts	IMUAccel	IMUObserver.java
-------------	--------	----------------
for IMUAccel expect 3 short ints (6 bytes total): x, y, z
for IMUGyro expect 3 short ints (6 bytes total): pitch, yaw, roll
values are opaque units

updates 3 stripcharts from each message
chart vertical axis expects values 0-4096

power		PowerID		APSObserver.java
-----		-------		----------------
				skeleton implementation

fc state	???????		FcStateObserver.java
--------	-------		--------------------
				skeleton implementation

rocket state	StatusID	RocketStateObserver.java
------------	--------	------------------------
				skeleton implementation

------------------------------------------------------------------
To: dcassard@psas.pdx.edu
From: Andrew Greenberg <andrew@uad.com>
Subject: bias and gain values for inertial sensors.

Hey Dave,

Here's the bias (intercept) and gain (slope) values for the accelerometers.

 X zero = 2400.45 +/- 0.02
 Y zero = 2462.06 +/- 0.02
 Z zero = 1918.72 +/- 0.01
 Q zero = 1907.53 +/- 0.01

 X gain = 392.8 +/- 5.8
 Y gain = 386.9 +/- 5.7
 Z gain = 77.0  +/- 2.4
 Q gain = 75.4  +/- 5.5

Here's how it works:

        (x in g's) = ((x raw value) - (x zero)) * (x gain)

You can ignore the +/- part: that's just measurement noise. (x in g's) is
then value of the x accelerometer in g's. Here's how I'd scale the graph:
        X: -5 to +5 g's, with graph ticks ~ every g.
        Y: -5 to +5 g's, with graph ticks ~ every g.
        Z: -20 to +20 g's, with graph ticks ~ every 5g

With of course zero being right in the vertical center of the stripchart.

Now here's how you deal with Q: if either X is out of range but Y is not,
then use Q to compensate, and vice versa. If both are out of range, game   
over, we just use saturated sensor value.

#define high_cutoff     4000
#define low_cutoff      95

If ( (((X raw value) > high_cutoff) || ((X raw value) < low_cutoff))
  && (((Y raw value) > low_cutoff)) && ((Y raw value) < high_cutoff))) )
{
        (X in g's) = (Q in g's) - ((y in q's) * sqrt(2));
}
else if ( (((Yraw value) > high_cutoff) || ((Y raw value) < low_cutoff))
       && (((X raw value) > low_cutoff)) && ((X raw value) < high_cutoff))) )
{
        (Y in g's) = (Q in g's) - ((X in q's) * sqrt(2)); 
}

Note of course that sqrt(2) is COS (45 degrees) which is the angle between
the Q and the X and Y sensors.

I hope that makes sense.

Andrew



